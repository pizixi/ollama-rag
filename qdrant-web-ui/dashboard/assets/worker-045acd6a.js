(function(){"use strict";function x(h,t){return Math.sqrt(F(h,t))}function F(h,t){if(h.length!=t.length)return;const e=h.length;let r=0;for(let s=0;s<e;++s){const n=h[s]-t[s];r+=n*n}return r}function Et(h,t){if(h.length!==t.length)return;let e=h.length,r=0,s=0,n=0;for(let i=0;i<e;++i)r+=h[i]*t[i],s+=h[i]*h[i],n+=t[i]*t[i];return Math.acos(r/(Math.sqrt(s)*Math.sqrt(n)))}function Tt(h,t){if(h.length!=t.length)return;const e=h.length;let r=0;for(let s=0;s<e;++s)r+=Math.abs(h[s]-t[s]);return r}function Ot(h,t){if(h.length!=t.length)return;const e=h.length;let r=[];for(let s=0;s<e;++s)r.push(Math.abs(h[s]-t[s]));return Math.max(...r)}function Pt(h,t){if(h.length!==t.length)return;const e=h.length;let r=0;for(let s=0;s<e;++s)r+=Math.abs(h[s]-t[s])/(Math.abs(h[s])+Math.abs(t[s]));return r}function kt(h,t){if(h.length!=t.length)return;const e=h.length;let r=0,s=0;for(let n=0;n<e;++n){const i=h[n]!=0,o=t[n]!=0;r+=i||o,s+=i&&o}return(r-s)/r}function Ft(h,t){if(h.length!=t.length)return;const e=h.length;let r=0;for(let s=0;s<e;++s)r+=h[s]!=t[s];return r/e}function Lt(h,t){if(h.length!=t.length)return;const e=h.length;let r=0;for(let s=0;s<e;++s)r+=h[s]!=0!=(t[s]!=0);return 2*r/(e+r)}function It(h,t){if(h.length!=t.length)return;const e=h.length;let r=0,s=0,n=0;for(let i=0;i<e;++i){const o=h[i]!=0,a=t[i]!=0;r+=o&&a,s+=o&&!a,n+=!o&&o}return s==0||n==0?0:2*s*n/(r*(e-r-s-n)+s*n)}function tt(h,t,e=x){const r=h.shape[0];let s=e=="precomputed"?h:R(h,e),n=new Array(r);for(let i=0;i<r;++i)n[i]=Array.from(s.row(i)).map((o,a)=>({i,j:a,distance:o})).sort((o,a)=>o.distance-a.distance).slice(1,t+1);return n}function R(h,t=x){let e=h.shape[0];const r=new w(e,e);for(let s=0;s<e;++s){const n=h.row(s);for(let i=s+1;i<e;++i){const o=t(n,h.row(i));r.set_entry(s,i,o),r.set_entry(i,s,o)}}return r}function N(h,t,e=null){if(e||(e=Math.max(Math.round(t-h)+1,1)),e<2)return e===1?[h]:[];let r=new Array(e);for(let s=e-=1;s>=0;--s)r[s]=(s*t+(e-s)*h)/e;return r}function B(h,t=x){let e=null;if(h instanceof w){let[s,n]=h.shape;if(s===1)e=h.row(0);else{if(n!==1)throw new Error("Matrix must be 1d!");e=h.col(0)}}else e=h;const r=e.length;return t(e,new Float64Array(r))}function Xt(h,t=x){const e=B(h,t);return h.map(r=>r/e)}function Rt(h){let t,e,r=h.length,s=0,n=0;for(let i=0;i<r;++i)t=h[i]-n,e=s+t,n=e-s-t,s=e;return s}function C(h){const t=h.length;let e=0,r=0;for(let s=0;s<t;++s){const n=h[s],i=e+n;Math.abs(e)>=Math.abs(n)?r+=e-i+n:r+=n-i+e,e=i}return e+r}function _t(h){const[t,e]=h.shape,r=new w(t,e,"identity"),s=new w(e,e,0);for(let n=0;n<e;++n){let i=h.col(n);for(let a=0;a<n;++a){const l=r.col(a),_=C(l.map((c,u)=>c*i[u]));for(let c=0;c<t;++c)i[c]-=_*l[c];s.set_entry(a,n,_)}const o=B(i,x);for(let a=0;a<t;++a)r.set_entry(a,n,i[a]/o);s.set_entry(n,n,o)}return{R:s,Q:r}}function Bt(h){const[t,e]=h.shape,r=new w(t,t,"I"),s=h.clone();for(let n=0;n<e;++n){const i=w.from(s.col(n).slice(n)),o=B(i),a=i.entry(0,0),l=-Math.sign(a),_=a-l*o,c=i.divide(_).set_entry(0,0,1),u=-l*_/o,d=c.outer(c),f=s.get_block(n,0),p=f.sub(d.dot(f).mult(u)),g=r.get_block(0,n),y=g.sub(g.dot(d).mult(u));s.set_block(n,0,p),r.set_block(0,n,y)}return{R:s,Q:r}}function E(h,t=2,{seed:e=1212,max_iterations:r=100,qr:s=_t,tol:n=1e-8}={}){const i=e instanceof P?e:new P(e);h instanceof w||(h=w.from(h));const o=h.shape[0];let{Q:a,R:l}=s(new w(o,t,()=>2*(i.random-.5)));for(;r--;){const _=a,c=s(h.dot(a));if(a=c.Q,l=c.R,F(a.values,_.values)<n)break}return{eigenvalues:l.diag,eigenvectors:a.transpose().to2dArray}}function qt(h,t){const e=h.length;if(e!=t.length)throw new Error("Array a and b must have the same length!");let r=0;for(let s=0;s<e;++s)r+=h*t;return r}class w{constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if(typeof r=="function"){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let n=0;n<e;++n)this._data[s*e+n]=r(s,n);return this}if(typeof r=="string"){if(r==="zeros")return new w(t,e,0);if(r==="identity"||r==="I"){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)this._data[s*e+s]=1;return this}if(r==="center"&&t==e){this._data=new Float64Array(t*e),r=(s,n)=>(s===n?1:0)-1/t;for(let s=0;s<t;++s)for(let n=0;n<e;++n)this._data[s*e+n]=r(s,n);return this}}if(typeof r=="number"){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let n=0;n<e;++n)this._data[s*e+n]=r;return this}}return this}static from(t,e="row"){if(t instanceof w)return t.clone();if(w.isArray(t)){let r=t.length;if(r===0)throw new Error("Array is empty");if(w.isArray(t[0])){let s=t[0].length;for(let n=0;n<r;++n)if(t[n].length!==s)throw new Error("various array lengths");return new w(r,s,(n,i)=>t[n][i])}if(e==="row")return new w(1,r,(s,n)=>t[n]);if(e==="col")return new w(r,1,s=>t[s]);if(e==="diag")return new w(r,r,(s,n)=>s==n?t[s]:0);throw new Error("1d array has NaN entries")}if(typeof t=="number")return new w(1,1,t);throw new Error("error")}row(t){const e=this.values,r=this._cols;return e.subarray(t*r,(t+1)*r)}*iterate_rows(){const t=this._cols,e=this._rows,r=this.values;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}set_row(t,e){const r=this._cols;if(w.isArray(e)&&e.length===r){const s=t*r;for(let n=0;n<r;++n)this.values[s+n]=e[n]}else{if(!(e instanceof w&&e.shape[1]===r&&e.shape[0]===1))throw new Error("Values not valid! Needs to be either an Array, a Float64Array, or a fitting Matrix!");{const s=t*r;for(let n=0;n<r;++n)this.values[s+n]=e._data[n]}}return this}swap_rows(t,e){const r=this._cols,s=this.values;for(let n=t*r,i=e*r,o=0;o<r;++o,++n,++i){const a=s[n];s[n]=s[i],s[i]=a}}col(t){const e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this.values[r*this._cols+t];return e}entry(t,e){return this.values[t*this._cols+e]}set_entry(t,e,r){return this.values[t*this._cols+e]=r,this}add_entry(t,e,r){return this.values[t*this._cols+e]+=r,this}sub_entry(t,e,r){return this.values[t*this._cols+e]-=r,this}transpose(){return new w(this._cols,this._rows,(t,e)=>this.entry(e,t))}get T(){return this.transpose()}inverse(){const t=this._rows,e=this._cols,r=this.clone(),s=new w(t,e,"I");for(let n=0;n<e;++n){let i=n,o=Math.abs(r.entry(n,n));for(let _=n+1;_<t;++_){const c=Math.abs(r.entry(_,n));o<c&&(i=_,o=c)}if(o===0)throw new Error("Cannot compute inverse of Matrix, determinant is zero");i!==n&&(r.swap_rows(n,i),s.swap_rows(n,i));const a=r.row(n),l=s.row(n);for(let _=0;_<t;++_)if(_!==n){const c=r.row(_),u=s.row(_);if(c[n]!==0){const d=c[n]/a[n];for(let f=n;f<e;++f)c[f]-=d*a[f];for(let f=0;f<e;++f)u[f]-=d*l[f]}}else{const c=a[n];for(let u=n;u<e;++u)a[u]/=c;for(let u=0;u<e;++u)l[u]/=c}}return s}dot(t){if(t instanceof w){let e=this;const[r,s]=e.shape,[n,i]=t.shape;if(s!==n)throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix:
                A has ${s} cols and B ${n} rows.
                Must be equal!`);return new w(r,i,(o,a)=>{const l=e.row(o),_=t.values;let c=0;for(let u=0,d=a;u<s;++u,d+=i)c+=l[u]*_[d];return c})}if(w.isArray(t)){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=C(this.row(s).map(n=>n*t[s]));return r}throw new Error("B must be Matrix or Array")}transDot(t){if(t instanceof w){let e=this;const[r,s]=e.shape,[n,i]=t.shape;if(r!==n)throw new Error(`A.dot(B): A is a ${[s,r].join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix:
                A has ${r} cols and B ${n} rows, which must be equal!`);return new w(s,i,(o,a)=>{const l=e.values,_=t.values;let c=0;for(let u=0,d=o,f=a;u<r;++u,d+=s,f+=i)c+=l[d]*_[f];return c})}if(w.isArray(t)){let e=this._cols;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=C(this.col(s).map(n=>n*t[s]));return r}throw new Error("B must be Matrix or Array")}dotTrans(t){if(t instanceof w){let e=this;const[r,s]=e.shape,[n,i]=t.shape;if(s!==i)throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${[i,n].join(" ⨯ ")}-Matrix:
                A has ${s} cols and B ${i} rows, which must be equal!`);return new w(r,n,(o,a)=>{const l=e.row(o),_=t.row(a);let c=0;for(let u=0;u<s;++u)c+=l[u]*_[u];return c})}if(w.isArray(t)){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=C(this.row(s).map(n=>n*t[s]));return r}throw new Error("B must be Matrix or Array")}outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new w;return s.shape=[r,r,(n,i)=>n<=i?e._data[n]*t._data[i]:s.entry(i,n)],s}concat(t,e="horizontal"){const r=this,[s,n]=r.shape,[i,o]=t.shape;if(e=="horizontal"){if(s!=i)throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${i} rows.`);const a=new w(s,n+o,"zeros");return a.set_block(0,0,r),a.set_block(0,n,t),a}if(e=="vertical"){if(n!=o)throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${n} columns, B has ${o} columns.`);const a=new w(s+i,n,"zeros");return a.set_block(0,0,r),a.set_block(s,0,t),a}if(e=="diag"){const a=new w(s+i,n+o,"zeros");return a.set_block(0,0,r),a.set_block(s,n,t),a}throw new Error(`type must be "horizontal" or "vertical", but type is ${e}!`)}set_block(t,e,r){const s=Math.min(this._rows-t,r.shape[0]),n=Math.min(this._cols-e,r.shape[1]);for(let i=0;i<s;++i)for(let o=0;o<n;++o)this.set_entry(i+t,o+e,r.entry(i,o));return this}get_block(t,e,r=null,s=null){const[n,i]=this.shape;if(s=s??i,(r=r??n)<=t||s<=e)throw new Error(`
                end_row must be greater than start_row, and
                end_col must be greater than start_col, but
                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`);const o=new w(r-t,s-e,"zeros");for(let a=t,l=0;a<r;++a,++l)for(let _=e,c=0;_<s;++_,++c)o.set_entry(l,c,this.entry(a,_));return o}gather(t,e){const r=t.length,s=e.length,n=new w(r,s);for(let i=0;i<r;++i){const o=t[i];for(let a=0;a<r;++a){const l=e[a];n.set_entry(i,a,this.entry(o,l))}}return n}_apply_array(t,e){const r=this.values,[s,n]=this.shape;for(let i=0,o=0;o<s;++o)for(let a=0;a<n;++a,++i)r[i]=t(r[i],e(o,a));return this}_apply_rowwise_array(t,e){return this._apply_array(e,(r,s)=>t[s])}_apply_colwise_array(t,e){const r=this.values,[s,n]=this.shape;for(let i=0,o=0;o<s;++o){const a=t[o];for(let l=0;l<n;++l,++i)r[i]=e(r[i],a)}return this}_apply(t,e){const r=this.values,[s,n]=this.shape;if(t instanceof w){const i=t.values,[o,a]=t.shape;if(o===1){if(n!==a)throw new Error("cols !== value_cols");for(let l=0,_=0;_<s;++_)for(let c=0;c<n;++c,++l)r[l]=e(r[l],i[c])}else if(a===1){if(s!==o)throw new Error("rows !== value_rows");for(let l=0,_=0;_<s;++_){const c=i[_];for(let u=0;u<n;++u,++l)r[l]=e(r[l],c)}}else{if(s!=o||n!=a)throw new Error("error");for(let l=0,_=s*n;l<_;++l)r[l]=e(r[l],i[l])}}else if(w.isArray(t))if(t.length===s)for(let i=0,o=0;o<s;++o){const a=t[o];for(let l=0;l<n;++l,++i)r[i]=e(r[i],a)}else{if(t.length!==n)throw new Error("error");for(let i=0,o=0;o<s;++o)for(let a=0;a<n;++a,++i)r[i]=e(r[i],t[a])}else for(let i=0,o=s*n;i<o;++i)r[i]=e(r[i],t);return this}clone(){let t=new w;return t._rows=this._rows,t._cols=this._cols,t._data=this.values.slice(0),t}mult(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,(r,s)=>r*s)}divide(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,(r,s)=>r/s)}add(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,(r,s)=>r+s)}sub(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,(r,s)=>r-s)}get shape(){return[this._rows,this._cols]}set shape([t,e,r=()=>0]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0,n=0;n<t;++n)for(let i=0;i<e;++i,++s)this._data[s]=r(n,i);return this}get to2dArray(){const t=[];for(const e of this.iterate_rows())t.push(e);return t}get asArray(){const t=[];for(const e of this.iterate_rows())t.push(Array.from(e));return t}get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let n=0;n<r;++n)s[n]=this.entry(n,n);return s}get mean(){return this.sum/(this._rows*this._cols)}get sum(){return C(this.values)}get values(){return this._data}get meanRows(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:e});for(let n=0,i=0;i<e;++i){let o=0;for(let a=0;a<r;++a,++n)o+=t[n];s[i]=o/r}return s}get meanCols(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:r});for(let n=0;n<r;++n){let i=0;for(let o=n,a=0;a<e;++a,o+=r)i+=t[o];s[n]=i/e}return s}static solve_CG(t,e,r,s=.001){r===null&&(r=new P);const n=t.shape[0],i=e.shape[1];let o=new w(n,0);for(let a=0;a<i;++a){const l=w.from(e.col(a)).T;let _=new w(n,1,()=>r.random),c=l.sub(t.dot(_)),u=c.clone();do{const d=t.dot(u),f=c.transDot(c).entry(0,0)/u.transDot(d).entry(0,0);_=_.add(u.mult(f));const p=c.sub(d.mult(f)),g=p.transDot(p).entry(0,0)/c.transDot(c).entry(0,0);u=p.add(u.mult(g)),c=p}while(Math.abs(c.mean)>s);o=o.concat(_,"horizontal")}return o}static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:w.LU(t),n=r.shape[0],i=e.clone();for(let o=0;o<n;++o){for(let a=0;a<o-1;++a)i.sub_entry(0,o,r.entry(o,a)*i.entry(1,a));i.set_entry(0,o,i.entry(0,o)/r.entry(o,o))}for(let o=n-1;o>=0;--o){for(let a=n-1;a>o;--a)i.sub_entry(0,o,s.entry(o,a)*i.entry(0,a));i.set_entry(0,o,i.entry(0,o)/s.entry(o,o))}return i}static LU(t){const e=t.shape[0],r=new w(e,e,"zeros"),s=new w(e,e,"identity");for(let n=0;n<e;++n){for(let i=n;i<e;++i){let o=0;for(let a=0;a<n;++a)o+=r.entry(i,a)*s.entry(a,n);r.set_entry(i,n,t.entry(i,n)-o)}for(let i=n;i<e;++i){if(r.entry(n,n)===0)return;let o=0;for(let a=0;a<n;++a)o+=r.entry(n,a)*s.entry(a,i);s.set_entry(n,i,(t.entry(n,i)-o)/r.entry(n,n))}}return{L:r,U:s}}static det(t){const e=t.shape[0],{L:r,U:s}=w.LU(t),n=r.diag,i=s.diag;let o=n[0]*i[0];for(let a=1;a<e;++a)o*=n[a]*i[a];return o}static SVD(t,e=2){let r=t.transDot(t),s=t.dotTrans(t),{eigenvectors:n,eigenvalues:i}=E(r,e),{eigenvectors:o}=E(s,e);return{U:o,Sigma:i.map(a=>Math.sqrt(a)),V:n}}static isArray(t){return Array.isArray(t)||t instanceof Float64Array||t instanceof Float32Array}}class P{constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||new Date().getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let r=this._mti,s=e[r-1]^e[r-1]>>>30;e[r]=(1812433253*((4294901760&s)>>>16)<<16)+1812433253*(65535&s)+r,e[r]>>>=0}}get seed(){return this._seed}get random(){return this.random_int*(1/4294967296)}get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r,s=this._N-this._M,n=this._M-this._N;for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+n]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}gauss_random(){let t,e,r;if(this._val!=null)return t=this._val,this._val=null,t;do t=2*this.random-1,e=2*this.random-1,r=t*t+e*e;while(!r||r>1);const s=Math.sqrt(-2*Math.log(r)/r);return this._val=e*s,t*s}choice(t,e){if(t instanceof w){let r=t.shape[0];if(e>r)throw new Error("n bigger than A!");let s=new Array(e),n=N(0,r-1);for(let i=0,o=n.length;i<e;++i,--o){let a=this.random_int%o;s[i]=n.splice(a,1)[0]}return s.map(i=>t.row(i))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw new Error("n bigger than A!");let s=new Array(e),n=N(0,r-1);for(let i=0,o=n.length;i<e;++i,--o){let a=this.random_int%o;s[i]=n.splice(a,1)[0]}return s.map(i=>t[i])}}static choice(t,e,r=1212){return new P(r).choice(t,e)}}function ct(h){let t;for(const e of h)e!=null&&(t<e||t===void 0&&e>=e)&&(t=e);return t}function Y(h){let t;for(const e of h)e!=null&&(t>e||t===void 0&&e<=e)&&(t=e);return t}class T{constructor(t=null,e=s=>s,r="min"){return t?T.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator=r=="min"?(s,n)=>s<n:r=="max"?(s,n)=>s>n:r,this)}static heapify(t,e=s=>s,r="min"){const s=new T(null,e,r),n=s._container;for(const i of t)n.push({element:i,value:e(i)});for(let i=Math.floor(t.length/2-1);i>=0;--i)s._heapify_down(i);return s}_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}push(t){const e={element:t,value:this._accessor(t)};return this._container.push(e),this._heapify_up(),this}_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let n=2*t+1,i=2*t+2,o=t;if(o>s)throw"index higher than length";n<s&&r(e[n].value,e[o].value)&&(o=n),i<s&&r(e[i].value,e[o].value)&&(o=i),o!==t&&(this._swap(t,o),this._heapify_down(o))}pop(){const t=this._container;if(t.length===0)return null;if(t.length===1)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}get first(){return this._container.length>0?this._container[0]:null}*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}toArray(){return this.data().sort((t,e)=>this._comparator(t,e)?-1:0)}data(){return this._container.map(t=>t.element)}raw_data(){return this._container}get length(){return this._container.length}get empty(){return this.length===0}}class G{constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,s.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}class H{constructor(t=null,e=x){return this._Node=class{constructor(r,s=null,n=null,i=null){this.pivot=r,this.child1=s,this.child2=n,this.radius=i}},this._Leaf=class{constructor(r){this.points=r}},this._metric=e,t&&this.add(t),this}add(t){return t=t.map((e,r)=>({index:r,element:e})),this._root=this._construct(t),this}_construct(t){if(t.length===1)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort((c,u)=>c.element[r]-u.element[r]),n=s.length,i=Math.floor(n/2),o=t[i],a=s.slice(0,i),l=s.slice(i,n),_=Math.max(...t.map(c=>this._metric(o.element,c.element)));return e=a.length>0&&l.length>0?new this._Node(o,this._construct(a),this._construct(l),_):new this._Leaf(t),e}}_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let i=0;i<e;++i)r[i]=[1/0,-1/0];let s=t.reduce((i,o)=>{for(let a=0;a<e;++a)i[a][0]=Math.min(i[a][0],o.element[a]),i[a][1]=Math.max(i[a][1],o.element[a]);return i},r);s=s.map(i=>i[1]-i[0]);let n=0;for(let i=0;i<e;++i)n=s[i]>s[n]?i:n;return n}search(t,e=5){return this._search(t,e,new T(null,r=>this._metric(r.element,t),"max"),this._root)}_search(t,e,r,s){if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let n=0,i=s.points.length;n<i;++n){let o=s.points[n];e>r.length?r.push(o):(r.push(o),r.pop())}return r}}class ut{constructor(t=null,e=x){this._metric=e,this._elements=t instanceof w?t:w.from(t);const r=this._elements.shape[0];this._D=e==="precomputed"?this._elements.clone():R(this._elements,e),this.KNN=[];for(let s=0;s<r;++s){const n=this._D.row(s),i=new T(null,o=>o.value,"min");for(let o=0;o<r;++o)i.push({value:n[o],index:o});this.KNN.push(i)}}search(t,e=5){const r=this._metric,s=this.KNN;let n;if(Array.isArray(t)){if(this._metric=="precomputed")throw"Search by query element is only possible when not using a precomputed distance matrix!";const o=this._elements,a=s.length;let l=null,_=1/0;for(let c=0;c<a;++c){const u=r(t,o.row(c));u<_&&(l=c,_=u)}n=s[l]}else Number.isInteger(t)&&(n=s[t]);let i=[];for(let o=0;o<e;++o)i.push(n.pop());return i.forEach(o=>n.push(o.element)),i}}class S{constructor(t,e,r){if(this._parameters=Object.assign(Object.seal(e),r),Array.isArray(t))this._type="array",this.X=w.from(t);else{if(!(t instanceof w))throw new Error("No valid type for X!");this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._randomizer=new P(this._parameters.seed),this._is_initialized=!1,this}parameter(t=null,e=null){if(t===null)return Object.assign({},this._parameters);if(!this._parameters.hasOwnProperty(t))throw new Error(`${t} is not a valid parameter!`);return e!==null?(this._parameters[t]=e,this._is_initialized=!1,this):this._parameters[t]}para(t=null,e=null){return this.parameter(t,e)}p(t=null,e=null){return this.parameter(t,e)}transform(){return this.check_init(),this.projection}*generator(){return this.transform()}check_init(){return this._is_initialized||typeof this.init!="function"||(this.init(),this._is_initialized=!0),this}get projection(){if(this.hasOwnProperty("Y"))return this.check_init(),this._type==="matrix"?this.Y:this.Y.to2dArray;throw new Error("The dataset is not transformed yet!")}async transform_async(...t){return this.transform(...t)}static transform(...t){return new this(...t).transform()}static async transform_async(...t){return this.transform(...t)}static*generator(...t){const e=new this(...t).generator();for(const r of e)yield r}}class et extends S{constructor(t,e){return super(t,{d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(t=null){const e=this.principal_components();if(t==null){const r=this.X;return this.Y=r.dot(e),this.projection}if(Array.isArray(t))return w.from(t).dot(e).asArray;if(t instanceof w)return t.dot(e);throw new Error("No valid type for A!")}principal_components(){if(this.V)return this.V;const{d:t,eig_args:e}=this._parameters,r=this.X,s=r.sub(r.meanCols),n=s.transDot(s),{eigenvectors:i}=E(n,t,e);return this.V=w.from(i).transpose(),this.V}static principal_components(t,e){return new this(t,e).principal_components()}}class rt extends S{constructor(t,e){return super(t,{d:2,metric:x,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){const t=this.X,e=t.shape[0],{d:r,metric:s,eig_args:n}=this._parameters,i=s==="precomputed"?t:R(t,s),o=i.meanCols,a=i.meanRows,l=i.mean;this._d_X=i;const _=new w(e,e,(u,d)=>i.entry(u,d)-o[u]-a[d]+l),{eigenvectors:c}=E(_,r,n);return this.Y=w.from(c).transpose(),this.projection}stress(){const t=this.X.shape[0],e=this.Y,r=this._d_X,s=new w;s.shape=[t,t,(o,a)=>o<a?x(e.row(o),e.row(a)):s.entry(a,o)];let n=0,i=0;for(let o=0;o<t;++o)for(let a=o+1;a<t;++a)n+=Math.pow(r.entry(o,a)-s.entry(o,a),2),i+=Math.pow(r.entry(o,a),2);return Math.sqrt(n/i)}}class Kt extends S{constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:x,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(this._parameters.neighbors??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){this.check_init();const t=this.X,e=this._N,{d:r,metric:s,eig_args:n,neighbors:i}=this._parameters,o=new w;o.shape=[e,e,(g,y)=>g<=y?s(t.row(g),t.row(y)):o.entry(y,g)];const a=[];for(let g=0;g<e;++g){const y=[];for(let b=0;b<e;++b)y.push({index:b,distance:o.entry(g,b)});const m=new T(y,b=>b.distance,"min");a.push(m.toArray().slice(1,i+1))}const l=new w(e,e,(g,y)=>{const m=a[g].find(b=>b.index===y);return m?m.distance:1/0});for(let g=0;g<e;++g)for(let y=0;y<e;++y){let m=l.entry(g,y);for(let b=0;b<e;++b)m=Math.min(m,l.entry(g,b)+l.entry(b,y));l.set_entry(g,y,m)}let _=new Float64Array(e),c=new Float64Array(e),u=0;const d=new w(e,e,(g,y)=>{let m=l.entry(g,y);return m=m===1/0?0:m,_[g]+=m,c[y]+=m,u+=m,m});_=_.map(g=>g/e),c=c.map(g=>g/e),u/=e**2;const f=new w(e,e,(g,y)=>d.entry(g,y)-_[g]-c[y]+u),{eigenvectors:p}=E(f,r,n);return this.Y=w.from(p).transpose(),this.projection}}class Yt extends S{constructor(t,e){return super(t,{d:2,metric:x,seed:1212},e),this}_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,n=-1/0;for(let i=0;i<e;++i){const o=t(r,i);o>n&&(n=o,s=i)}n=-1/0;for(let i=0;i<e;++i){const o=t(s,i);o>n&&(n=o,r=i)}return[r,s,n]}transform(){const t=this.X,e=t.shape[0],{d:r,metric:s}=this._parameters,n=new w(e,r,0);let i=(o,a)=>s(t.row(o),t.row(a));for(let o=0;o<r;++o){let a=i;const[l,_,c]=this._choose_distant_objects(i);if(c!==0){for(let u=0;u<e;++u){const d=(i(l,u)**2+c**2-i(_,u)**2)/(2*c);n.set_entry(u,o,d)}i=(u,d)=>Math.sqrt(a(u,d)**2-(n.entry(u,o)-n.entry(d,o))**2)}}return this.Y=n,this.projection}}class Gt extends S{constructor(t,e){return super(t,{labels:null,d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){const t=this.X,[e,r]=t.shape,{d:s,labels:n,eig_args:i}=this._parameters;if(n===null||n.length!=e)throw new Error("LDA needs parameter label to every datapoint to work!");const o={};let a=0;n.forEach((f,p)=>{f in o?(o[f].count++,o[f].rows.push(t.row(p))):o[f]={id:a++,count:1,rows:[t.row(p)]}});const l=t.mean,_=new w(a,r);for(const f in o){const p=w.from(o[f].rows).meanCols;for(let g=0;g<r;++g)_.set_entry(o[f].id,g,p[g])}let c=new w(r,r);for(const f in o){const p=_.row(o[f].id),g=new w(r,1,m=>p[m]-l),y=o[f].count;c=c.add(g.dotTrans(g).mult(y))}let u=new w(r,r);for(const f in o){const p=_.row(o[f].id),g=new w(r,1,m=>p[m]),y=o[f].rows;for(let m=0,b=o[f].count;m<b;++m){const v=new w(r,1,(A,M)=>y[m][A]-g.entry(A,0));u=u.add(v.dotTrans(v))}}let{eigenvectors:d}=E(u.inverse().dot(c),s,i);return d=w.from(d).transpose(),this.Y=t.dot(d),this.projection}}class Ht extends S{constructor(t,e){return super(t,{neighbors:void 0,d:2,metric:x,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){const t=this.X,e=this._N,r=this._D,{neighbors:s,d:n,eig_args:i,metric:o}=this._parameters,a=tt(t,s,o),l=new w(s,1,1),_=new w(e,e);for(let f=0;f<e;++f){const p=a[f],g=new w(s,r,(b,v)=>t.entry(p[b].j,v)-t.entry(f,v)),y=g.dotTrans(g);if(s>r){const b=C(y.diag)/1e3;for(let v=0;v<s;++v)y.add_entry(v,v,b)}let m=w.solve_CG(y,l,this._randomizer);m=m.divide(m.sum);for(let b=0;b<s;++b)_.set_entry(f,p[b].j,m.entry(b,0))}const c=new w(e,e,"identity").sub(_),u=c.transDot(c),{eigenvectors:d}=E(u.T.inverse(),n+1,i);return this.Y=w.from(d.slice(1,1+n)).T,this.projection}}class Ut extends S{constructor(t,e){if(super(t,{neighbors:void 0,d:2,metric:x,seed:1212,eig_args:{}},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this._D<=this.parameter("d"))throw new Error(`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${this.parameter("d")})!`);return this}transform(){const t=this.X,[e,r]=t.shape,{d:s,neighbors:n,metric:i,eig_args:o}=this._parameters,a=tt(t,n,i),l=new w(r,r,"center"),_=new w(e,e,0);for(let u=0;u<e;++u){const d=[u,...a[u].map(b=>b.j)];let f=w.from(d.map(b=>t.row(b)));f=f.dot(l);const p=f.dotTrans(f),{eigenvectors:g}=E(p,s,o),y=w.from(g),m=y.transDot(y).add(1/Math.sqrt(n+1));for(let b=0;b<n+1;++b)for(let v=0;v<n+1;++v)_.add_entry(d[b],d[v],m.entry(b,v)-(b===v?1:0))}const{eigenvectors:c}=E(_,s+1,o);return this.Y=w.from(c.slice(1)).transpose(),this.projection}}class Vt extends S{constructor(t,e){return super(t,{perplexity:50,epsilon:10,d:2,metric:F,seed:1212},e),[this._N,this._D]=this.X.shape,this._iter=0,this.Y=new w(this._N,this.parameter("d"),()=>1e-4*this._randomizer.gauss_random()),this}init(){const t=Math.log(this.parameter("perplexity")),e=this._N,r=this._D,{metric:s}=this._parameters,n=this.X;let i;if(s=="precomputed")i=druid.Matrix.from(n);else{i=new w(e,e);for(let l=0;l<e;++l){const _=n.row(l);for(let c=l+1;c<e;++c){const u=s(_,n.row(c));i.set_entry(l,c,u),i.set_entry(c,l,u)}}}const o=new w(e,e,0);this._ystep=new w(e,r,0),this._gains=new w(e,r,1);for(let l=0;l<e;++l){const _=i.row(l),c=o.row(l);let u,d=-1/0,f=1/0,p=1,g=50,y=!1;for(;!y&&g--;){u=0;let m=0;for(let v=0;v<e;++v){const A=_[v],M=l!==v?Math.exp(-A*p):0;m+=A*M,c[v]=M,u+=M}const b=u>0?Math.log(u)+p*m/u:0;b>t?(d=p,p=f===1/0?2*p:(p+f)/2):(f=p,p=d===-1/0?p/2:(p+d)/2),y=Math.abs(b-t)<1e-4}for(let m=0;m<e;++m)c[m]/=u}const a=2*e;for(let l=0;l<e;++l)for(let _=l;_<e;++_){const c=Math.max((o.entry(l,_)+o.entry(_,l))/a,1e-100);o.set_entry(l,_,c),o.set_entry(_,l,c)}return this._P=o,this}transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}*generator(t=500){this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,n=this._N,{d:i,epsilon:o}=this._parameters;let a=this.Y;const l=t<100?4:1,_=new w(n,n,"zeros");let c=0;for(let p=0;p<n;++p)for(let g=p+1;g<n;++g){let y=0;for(let b=0;b<i;++b){const v=a.entry(p,b)-a.entry(g,b);y+=v*v}const m=1/(1+y);_.set_entry(p,g,m),_.set_entry(g,p,m),c+=2*m}const u=new w(n,n,0);for(let p=0;p<n;++p)for(let g=p+1;g<n;++g){const y=Math.max(_.entry(p,g)/c,1e-100);u.set_entry(p,g,y),u.set_entry(g,p,y)}const d=new w(n,i,"zeros");for(let p=0;p<n;++p)for(let g=0;g<n;++g){const y=4*(l*e.entry(p,g)-u.entry(p,g))*_.entry(p,g);for(let m=0;m<i;++m)d.add_entry(p,m,y*(a.entry(p,m)-a.entry(g,m)))}let f=new Float64Array(i);for(let p=0;p<n;++p)for(let g=0;g<i;++g){const y=d.entry(p,g),m=r.entry(p,g),b=s.entry(p,g);let v=Math.sign(y)===Math.sign(m)?.8*b:b+.2;v<.01&&(v=.01),s.set_entry(p,g,v);const A=(t<250?.5:.8)*m-o*v*y;r.set_entry(p,g,A),a.add_entry(p,g,A),f[g]+=a.entry(p,g)}for(let p=0;p<n;++p)for(let g=0;g<i;++g)a.sub_entry(p,g,f[g]/n);return this.Y}}function dt(h,t,e=300){const r=t.length;let s=.001,n=1e4,i=t.slice(),o=h(i),a=!1;for(;e-->=0&&!a;){a=!0;for(let l=0;l<r;++l){i[l]+=1e-6;let _=h(i);i[l]-=1e-6;let c=(_-o)/1e-6;Math.abs(c)>.01&&(a=!1),i[l]-=s*c,o=h(i)}s*=n>=o?1.05:.4,n=o}return i}class Qt extends S{constructor(t,e){if(super(t,{n_neighbors:15,local_connectivity:1,min_dist:1,d:2,metric:x,seed:1212,_spread:1,_set_op_mix_ratio:1,_repulsion_strength:1,_negative_sample_rate:5,_n_epochs:350,_initial_alpha:1},e),[this._N,this._D]=this.X.shape,this.parameter("n_neighbors")>this._N)throw new Error(`Parameter n_neighbors (=${this.parameter("n_neighbors")}) needs to be smaller than dataset size (N=${this._N})!`);if(this.parameter("local_connectivity")>this.parameter("n_neighbors"))throw new Error(`Parameter local_connectivity (=${this.parameter("local_connectivity")}) needs to be smaller than parameter n_neighbors (=${this.parameter("n_neighbors")})`);this._iter=0;const r=this._randomizer;return this.Y=new w(this._N,this.parameter("d"),()=>r.random),this}_find_ab_params(t,e){const r=N(0,3*t,300),s=N(0,3*t,300);for(let n=0,i=r.length;n<i;++n){const o=r[n];s[n]=o<e?1:Math.exp(-(o-e)/t)}return dt(n=>{const i=N(1,300).map((o,a)=>{return s[a]-(l=r[a],_=n[0],c=n[1],1/(1+_*Math.pow(l,2*c)));var l,_,c});return Math.sqrt(C(i.map(o=>o*o)))},[1,1])}_compute_membership_strengths(t,e,r){for(let s=0,n=t.length;s<n;++s){const i=r[s],o=t[s];for(let a=0,l=o.length;a<l;++a){const _=o[a].value-i;o[a].value=_>0?Math.exp(-_/e[s]):1}}return t}_smooth_knn_dist(t,e){const{local_connectivity:n,metric:i}=this._parameters,o=Math.log2(e),a=[],l=[],_=this.X,c=_.shape[0],u=[];if(i==="precomputed")for(let p=0;p<c;++p)u.push(t.search(p,e).reverse());else for(const p of _)u.push(t.search(p,e).raw_data().reverse());const d=Math.floor(n),f=n-d;for(let p=0;p<c;++p){let g=0,y=1/0,m=1,b=0;const v=u[p],A=v.filter($=>$.value>0),M=A.length;M>=n?d>0?(b=A[d-1].value,f>1e-5&&(b+=f*(A[d].value-A[d-1].value))):b=f*A[0].value:M>0&&(b=A[M-1].value);for(let $=0;$<64;++$){let j=0;for(let z=0;z<e;++z){const D=v[z].value-b;j+=D>0?Math.exp(-D/m):1}if(Math.abs(j-o)<1e-5)break;j>o?[y,m]=[m,(g+y)/2]:[g,m]=y===1/0?[m,2*m]:[m,(g+y)/2]}if(b>0){const $=v.reduce((j,z)=>j+z.value,0)/v.length;m<.001*$&&(m=.001*$)}else{const $=u.reduce((j,z)=>j+z.reduce((D,O)=>D+O.value,0)/z.length);m<.001*$&&(m=.001*$)}a[p]=b,l[p]=m}return{distances:u,sigmas:l,rhos:a}}_fuzzy_simplicial_set(t,e){const r=t.shape[0],{metric:s,_set_op_mix_ratio:n}=this._parameters,i=s==="precomputed"?new ut(t,"precomputed"):new H(t.to2dArray,s);let{distances:o,sigmas:a,rhos:l}=this._smooth_knn_dist(i,e);o=this._compute_membership_strengths(o,a,l);const _=new w(r,r,"zeros");for(let d=0;d<r;++d){const f=o[d];for(let p=0;p<f.length;++p)_.set_entry(d,f[p].element.index,f[p].value)}const c=_.T,u=_.mult(c);return _.add(c).sub(u).mult(n).add(u.mult(1-n))}_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=t/ct(e);return e.forEach((n,i)=>{const o=n*s;o>0&&(r[i]=Math.round(t/o))}),r}_tocoo(t){const e=[],r=[],s=[],[n,i]=t.shape;for(let o=0;o<n;++o)for(let a=0;a<i;++a){const l=t.entry(o,a);l!==0&&(e.push(o),r.push(a),s.push(l))}return{rows:e,cols:r,data:s}}init(){const{_spread:t,min_dist:e,n_neighbors:r,_n_epochs:s,_negative_sample_rate:n}=this._parameters,[i,o]=this._find_ab_params(t,e);this._a=i,this._b=o,this._graph=this._fuzzy_simplicial_set(this.X,r);const{rows:a,cols:l,data:_}=this._tocoo(this._graph);return this._head=a,this._tail=l,this._weights=_,this._epochs_per_sample=this._make_epochs_per_sample(s),this._epochs_per_negative_sample=this._epochs_per_sample.map(c=>c*n),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}transform(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}*generator(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}_clip(t){return t>4?4:t<-4?-4:t}_optimize_layout(t,e,r,s){const n=this._randomizer,{_repulsion_strength:i,d:o}=this._parameters,{_alpha:a,_a:l,_b:_,_epochs_per_sample:c,_epochs_per_negative_sample:u,_epoch_of_next_negative_sample:d,_epoch_of_next_sample:f,_clip:p}=this,g=s.length;for(let y=0,m=c.length;y<m;++y)if(f[y]<=this._iter){const b=r[y],v=s[y],A=t.row(b),M=e.row(v),$=F(A,M);if($>0){const z=-2*l*_*Math.pow($,_-1)/(l*Math.pow($,_)+1);for(let D=0;D<o;++D){const O=p(z*(A[D]-M[D]))*a;A[D]+=O,M[D]-=O}}f[y]+=c[y];const j=(this._iter-d[y])/u[y];for(let z=0;z<j;++z){const D=n.random_int%g,O=e.row(s[D]),K=F(A,O);if(K>0){const lt=2*i*_/((.01+K)*(l*Math.pow(K,_)+1));for(let k=0;k<o;++k){const J=p(lt*(A[k]-O[k]))*a;A[k]+=J,O[k]-=J}}else if(b===D)continue}d[y]+=j*u[y]}return t}next(){const t=++this._iter,e=this.Y,{_initial_alpha:r,_n_epochs:s}=this._parameters;return this._alpha=r*(1-t/s),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}class Wt extends S{constructor(t,e){return super(t,{weight_adj:500,c:5,d:2,metric:x,tol:1e-8,seed:1212},e),this}init(t=null,e=null){const r=this.X,s=r.shape[0],{c:n,d:i,metric:o,seed:a}=this._parameters;this.n_inliers=2*n,this.n_outliers=1*n,this.n_random=1*n,this.Y=t||new et(r,{d:i,seed:a}).transform(),this.knn=e||new H(r.to2dArray,o);const{triplets:l,weights:_}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=l,this.weights=_,this.lr=1e3*s/l.shape[0],this.C=1/0,this.vel=new w(s,i,0),this.gain=new w(s,i,1),this}_generate_triplets(t,e,r){const{metric:s,weight_adj:n}=this._parameters,i=this.X,o=i.shape[0],a=this.knn,l=Math.min(t+20,o),_=new w(o,l),c=new w(o,l);for(let v=0;v<o;++v)a.search(i.row(v),l+1).raw_data().filter(A=>A.value!=0).sort((A,M)=>A.value-M.value).forEach((A,M)=>{_.set_entry(v,M,A.element.index),c.set_entry(v,M,A.value)});const u=new Float64Array(o);for(let v=0;v<o;++v)u[v]=Math.max((c.entry(v,3)+c.entry(v,4)+c.entry(v,5)+c.entry(v,6))/4,1e-10);const d=this._find_p(c,u,_);let f=this._sample_knn_triplets(d,_,t,e),p=f.shape[0];const g=new Float64Array(p);for(let v=0;v<p;++v){const A=f.entry(v,0),M=f.entry(v,2);g[v]=s(i.row(A),i.row(M))}let y=this._find_weights(f,d,_,g,u);if(r>0){const{random_triplets:v,random_weights:A}=this._sample_random_triplets(i,r,u);f=f.concat(v,"vertical"),y=Float64Array.from([...y,...A])}p=f.shape[0];let m=-1/0;for(let v=0;v<p;++v)isNaN(y[v])&&(y[v]=0),m<y[v]&&(m=y[v]);let b=-1/0;for(let v=0;v<p;++v)y[v]/=m,y[v]+=1e-4,y[v]=Math.log(1+n*y[v]),b<y[v]&&(b=y[v]);for(let v=0;v<p;++v)y[v]/=b;return{triplets:f,weights:y}}_find_p(t,e,r){const[s,n]=t.shape;return new w(s,n,(i,o)=>Math.exp(-(t.entry(i,o)**2)/e[i]/e[r.entry(i,o)]))}_sample_knn_triplets(t,e,r,s){const n=e.shape[0],i=new w(n*r*s,3);for(let o=0;o<n;++o){let a=o*r*s;const l=this.__argsort(t.row(o));for(let _=0;_<r;++_){let c=_*s;const u=e.entry(o,l[_]),d=this._rejection_sample(s,n,l.slice(0,_+1));for(let f=0;f<s;++f){const p=a+c+f,g=d[f];i.set_entry(p,0,o),i.set_entry(p,1,u),i.set_entry(p,2,g)}}}return i}__argsort(t){return N(0,t.length-1).sort((e,r)=>t[r]-t[e])}_rejection_sample(t,e,r){const s=this._randomizer,n=N(0,e-1).filter(i=>r.indexOf(i)<0);return s.choice(n,Math.min(t,n.length-2))}_find_weights(t,e,r,s,n){const i=t.shape[0],o=new Float64Array(i);for(let a=0;a<i;++a){const l=t.entry(a,0),_=r.row(l).indexOf(t.entry(a,1)),c=e.entry(l,_);let u=Math.exp(-(s[a]**2)/(n[l]*n[t.entry(a,2)]));u<1e-20&&(u=1e-20),o[a]=c/u}return o}_sample_random_triplets(t,e,r){const s=this.parameter("metric"),n=this._randomizer,i=t.shape[0],o=new w(i*e,3),a=new Float64Array(i*e);for(let l=0;l<i;++l){const _=l*e,c=[...N(0,l-1),...N(l+1,i-1)];for(let u=0;u<e;++u){let[d,f]=n.choice(c,2),p=Math.exp(-(s(t.row(l),t.row(d))**2)/(r[l]*r[d]));p<1e-20&&(p=1e-20);let g=Math.exp(-(s(t.row(l),t.row(f))**2)/(r[l]*r[f]));g<1e-20&&(g=1e-20),p<g&&([d,f]=[f,d],[p,g]=[g,p]);const y=_+u;o.set_entry(y,0,l),o.set_entry(y,1,d),o.set_entry(y,2,f),a[y]=p/g}}return{random_triplets:o,random_weights:a}}_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,n=this.weights,[i,o]=t.shape,a=s.shape[0],l=new w(i,o,0);let _=new Float64Array(o),c=new Float64Array(o),u=1,d=1,f=0,p=0;const g=i*e*r;for(let y=0;y<a;++y){const[m,b,v]=s.row(y);if(y%r==0||y>=g){u=1,d=1;for(let M=0;M<o;++M){const $=t.entry(m,M),j=t.entry(b,M),z=t.entry(v,M);_[M]=$-j,c[M]=$-z,u+=_[M]**2,d+=c[M]**2}}else{d=1;for(let M=0;M<o;++M){const $=t.entry(m,M),j=t.entry(v,M);c[M]=$-j,d+=c[M]**2}}u>d&&++f,p+=n[y]/(1+d/u);const A=(n[y]/(u+d))**2;for(let M=0;M<o;++M){const $=_[M]*d*A,j=c[M]*u*A;l.add_entry(m,M,$-j),l.sub_entry(b,M,$),l.add_entry(v,M,j)}}return{grad:l,loss:p,n_viol:f}}transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}*generator(t=800){this.check_init();for(let e=0;e<t;++e)this._next(e),yield this.projection;return this.projection}_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,n=this.Y.add(s.mult(e)),{grad:i,loss:o,n_viol:a}=this._grad(n);return this.C=o,this.Y=this._update_embedding(n,t,i),this.lr*=r>o+this._parameters.tol?1.01:.9,this.Y}_update_embedding(t,e,r){const[s,n]=t.shape,i=e>150?.9:.5,o=this.gain,a=this.vel,l=this.lr;for(let _=0;_<s;++_)for(let c=0;c<n;++c){const u=Math.sign(a.entry(_,c))!=Math.sign(r.entry(_,c))?o.entry(_,c)+.2:Math.max(.8*o.entry(_,c),.01);o.set_entry(_,c,u),a.set_entry(_,c,i*a.entry(_,c)-l*o.entry(_,c)*r.entry(_,c)),t.set_entry(_,c,t.entry(_,c)+a.entry(_,c))}return t}}class Jt{constructor(t,e="complete",r=x){if(this._id=0,this._matrix=t instanceof w?t:w.from(t),this._metric=r,this._linkage=e,r==="precomputed"&&this._matrix.shape[0]!==this._matrix.shape[1])throw new Error("If metric is 'precomputed', then matrix has to be square!");return this.init(),this.root=this.do(),this}get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=n=>n.dist;break;case"depth":r=n=>n.depth;break;default:throw new Error("invalid type")}return this._traverse(this.root,r,t,s),s}_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let n;if(t!=="precomputed"){n=new w(r,r,0);for(let a=0;a<r;++a){s[a]=0;for(let l=0;l<r;++l)n.set_entry(a,l,a===l?1/0:t(e.row(a),e.row(l))),n.entry(a,s[a])>n.entry(a,l)&&(s[a]=l)}}else{n=this._matrix.clone();for(let a=0;a<r;++a)for(let l=0;l<r;++l)a===l?n.set_entry(a,l,1/0):n.entry(a,s[a])>n.entry(a,l)&&(s[a]=l)}this._distance_matrix=n;const i=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let a=0;a<r;++a)i[a]=[],i[a][0]=new ft(this._id++,null,null,0,e.row(a),a,1,0),o[a]=1;return this}do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,n=this._c_size,i=this._linkage;let o=null;for(let a=0,l=t-1;a<l;++a){let _=0;for(let m=0;m<t;++m){let b=r.entry(m,e[m]);for(let v=m+1;v<t;++v)b>r.entry(m,v)&&(e[m]=v,b=r.entry(m,e[m]))}for(let m=0;m<t;++m)r.entry(m,e[m])<r.entry(_,e[_])&&(_=m);let c=e[_],u=s[_][0],d=s[c][0],f=u.isLeaf?[u.index]:u.index,p=d.isLeaf?[d.index]:d.index,g=f.concat(p),y=new ft(this._id++,u,d,r.entry(_,c),null,g);u.parent=y,d.parent=y,s[_].unshift(y),n[_]+=n[c];for(let m=0;m<t;++m){const b=r.entry(_,m),v=r.entry(c,m);let A;switch(i){case"single":A=Math.min(b,v);break;case"complete":A=Math.max(b,v);break;case"average":A=(n[_]*b+n[c]*v)/(n[_]+n[m])}r.set_entry(m,_,A),r.set_entry(_,m,A)}r.set_entry(_,_,1/0);for(let m=0;m<t;++m)r.set_entry(m,c,1/0),r.set_entry(c,m,1/0);o=y}return o}}class ft{constructor(t,e,r,s,n,i,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=i,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=n??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,n=t.centroid,i=e.centroid,o=this.size,a=t.centroid.length,l=new Float64Array(a);for(let _=0;_<a;++_)l[_]=(r*n[_]+s*i[_])/o;return l}get isLeaf(){return this.depth===0}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}class Zt{constructor(t,e,r=x,s=1987,n=!0){this._metric=r,this._matrix=t,this._K=e;const[i,o]=t.shape;return this._N=i,this._D=o,e>i&&(e=i),this._randomizer=new P(s),this._clusters=new Array(i).fill(void 0),this._cluster_centroids=this._get_random_centroids(e),n&&this.init(e,this._cluster_centroids),this}get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map(()=>new Array);return e.forEach((s,n)=>r[s].push(n)),r}_furthest_point(t,e){const r=this._matrix,s=this._metric;let n=t.length;return T.heapify(e,i=>{const o=r.row(i);let a=0;for(let l=0;l<n;++l)a+=s(o,t[l]);return a},"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,n=new Array(t).fill(),i=N(0,e-1),o=r.random_int%(e-1);n[0]=s.row(o);const a=[o],l=Math.floor((e-t)/t);for(let _=1;_<t;++_){const c=r.choice(i.filter(d=>a.indexOf(d)==-1),l),u=this._furthest_point(n.slice(0,_),c);a.push(u),n[_]=s.row(u)}return n}_iteration(t){const e=t.length,r=this._N,s=this._D,n=this._matrix,i=this._metric,o=this._clusters;let a=!1;for(let l=0;l<r;++l){const _=n.row(l);let c=1/0,u=null;for(let d=0;d<e;++d){let f=i(t[d],_);f<c&&(c=f,u=d)}o[l]!==u&&(a=!0),o[l]=u}for(let l=0;l<e;++l){const _=t[l];for(let c=0;c<s;++c)_[c]=0}return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,n=this._matrix,i=this._clusters,o=new Array(e).fill(0);for(let a=0;a<r;++a){const l=n.row(a),_=i[a];o[_]++;const c=t[_];for(let u=0;u<s;++u)c[u]+=l[u]}for(let a=0;a<e;++a){const l=o[a];t[a]=t[a].map(_=>_/l)}}init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const s=this._iteration(e);e=s.cluster_centroids,r=s.clusters_changed}while(r)}}class pt{constructor(t,e,r=null,s=x,n=1212){this._metric=s,this._matrix=t,this._A=this._matrix.to2dArray,this._K=e;const[i,o]=t.shape;return this._N=i,this._D=o,this._max_iter=r||10*Math.log10(i),this._distance_matrix=new w(i,i,"zeros"),e>i&&(e=i),this._randomizer=new P(n),this._clusters=new Array(i).fill(void 0),this._cluster_medoids=this._get_random_medoids(e),this._is_initialized=!1,this}get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map(()=>new Array);return e.forEach((s,n)=>{r[this._nearest_medoid(s,n).index_nearest].push(n)}),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do e=this._iteration(),yield this.get_clusters();while(!e&&++r<t)}_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map((o,a)=>this._nearest_medoid(o,a)),n=new Array(e).fill(0),i=new Array(e).fill(null);if(t.forEach((o,a)=>{if(r.findIndex(l=>l===a)<0){const l=s[a].distance_nearest,_=new Array(e).fill(-l);t.forEach((c,u)=>{if(a===u)return;const d=this._get_distance(u,a,c,o),{index_nearest:f,distance_nearest:p,distance_second:g}=s[u];if(_[f]+=Math.min(d,g)-p,d<p)for(let y=0;y<e;++y)y!==f&&(_[y]+=d-p)}),_.map((c,u)=>[c,u]).filter(([c,u])=>c<n[u]).forEach(([c,u])=>{c<n[u]&&(n[u]=c,i[u]=a)})}}),Y(n)>=0)return!0;for(;Y(n)<0;){const o=n.map((a,l)=>[a,l]).sort(([a],[l])=>a-l)[0][1];r.filter(a=>a==i[o]).length==0&&(r[o]=i[o]),n[o]=0,n.map((a,l)=>[a,l]).filter(([a])=>a<0).forEach(([a,l])=>{const _=t[l];let c=0;t.forEach((u,d)=>{r.findIndex(f=>f!=l&&f==d)>=0||o!=l&&(s[d].index_nearest===r[l]?c+=Math.min(this._get_distance(d,l,u,_),s[d].distance_second)-s[d].distance_nearest:c+=Math.min(this._get_distance(d,l,u,_)-s[d].distance_nearest,0))}),n[l]=c})}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const n=this._distance_matrix,i=this._A,o=this._metric;let a=n.entry(t,e);return a===0&&(a=o(r||i[t],s||i[e]),n.set_entry(t,e,a),n.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[n,i]=r.map((o,a)=>{const l=s[o];return[this._get_distance(e,o,t,l),a]}).sort((o,a)=>o[0]-a[0]);return{distance_nearest:n[0],index_nearest:n[1],distance_second:i[0],index_second:i[1]}}init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,n=0;do s=this._iteration();while(!s&&++n<r);return this}_get_random_medoids(t){const e=this._N,r=this._A,s=N(0,e-1),n=this._randomizer,i=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(i).fill(1/0),a=[];let l=1/0,_=n.choice(s,i);for(let c=0;c<i;++c){const u=_[c],d=r[u];for(let f=0;f<i;++f){if(f===c)continue;const p=r[_[f]];o[c]+=this._get_distance(c,f,d,p)}o[c]<l&&(l=o[c],a.push(u))}for(let c=1;c<t;++c){let u=1/0;_=n.choice(s.filter(d=>a.findIndex(f=>f===d)<0),i);for(let d=0;d<i;++d){let f=0;const p=_[d],g=r[p];for(let y=0;y<i;++y){if(y===d)continue;const m=_[y],b=r[m];let v=this._get_distance(p,m,g,b)-Y(a.map(A=>this._get_distance(m,A,b)));v<0&&(f+=v)}f<u&&(u=f,a.push(p))}l+=u}return a.slice(0,t)}}class te{constructor(t,e,r,s=x){return this._matrix=t,this._epsilon=e,this._min_points=r,this._metric=s,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,n=this._clusters;let i=this._cluster_index=0;for(let o=0;o<r;++o)s[o]={element:e.row(o),index:o,reachability_distance:void 0,processed:!1};for(const o of s)if(!o.processed&&(o.neighbors=this._get_neighbors(o),o.processed=!0,n.push([o.index]),i=n.length-1,t.push(o),this._core_distance(o)!=null)){const a=new T(null,l=>l.reachability_distance,"min");this._update(o,a),this._expand_cluster(a,n[i])}return this}_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,n=[];for(const i of e)i.index!=t.index&&r(t.element,i.element)<s&&n.push(i);return n}_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}_update(t,e){const r=this._metric,s=this._core_distance(t),n=this._get_neighbors(t);for(const i of n){if(i.processed)continue;const o=Math.max(s,r(t.element,i.element));e.raw_data().findIndex(a=>a.element==i)<0?(i.reachability_distance=o,e.push(i)):o<i.reachability_distance&&(i.reachability_distance=o,e=T.heapify(e.data(),a=>a.reachability_distance,"min"))}}_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),this._core_distance(s)!=null&&(this._update(s,t),this._expand_cluster(t,e))}}get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let s=0,n=r.length;s<n;++s){const i=r[s];for(const o of i)e[o]=s<n-1?s:-1}return e}}class ee extends S{constructor(t,e){return super(t,{neighbors:void 0,control_points:void 0,d:2,metric:x,seed:1212},e),this.parameter("neighbors",Math.min(e.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(e.control_points??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}init(t=rt,e={},r=H){if(this._is_initialized)return this;const s=this.X,n=this._N,i=this.parameter("neighbors"),o=this.parameter("d"),a=this.parameter("seed"),l=this.parameter("metric");e=Object.assign({d:o,metric:l,seed:a},e);const _=this.parameter("control_points"),c=new pt(s,_,null,l).get_clusters().medoids,u=new w(_,n,"zeros");c.forEach((v,A)=>{u.set_entry(A,v,1)});const d=new t(w.from(c.map(v=>s.row(v))),e).transform(),f=s.to2dArray,p=new r(f,l),g=new w(n,n,"I"),y=-1/i;f.forEach((v,A)=>{for(const{index:M}of p.search(v,i).iterate())A!==M&&g.set_entry(A,M,y)});const m=g.concat(u,"vertical"),b=new w(n,o,"zeros").concat(d,"vertical");return this._A=m,this._b=b,this._is_initialized=!0,this}transform(){this.check_init();const t=this._A,e=this._b,r=t.transDot(t),s=t.transDot(e);return this.Y=w.solve_CG(r,s,this._randomizer),this.projection}}class re extends S{constructor(t,e){return super(t,{metric:x,seed:1212},e),[this._N,this._D]=this.X.shape,this._distance_matrix=new w(this._N,this._N,0),this}__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,n=this.X,i=s.entry(t,e);if(i===0){let o=r(n.row(t),n.row(e));return s.set_entry(t,e,o),s.set_entry(e,t,o),o}return i}_make_minimum_spanning_tree(t=x){const e=this._N,r=[...this.X];let s=new G(r);const n=[];let i=[];for(let o=0;o<e;++o)for(let a=o+1;a<e;++a)i.push([o,a,this.__lazy_distance_matrix(o,a,t)]);i=i.sort((o,a)=>o[2]-a[2]);for(const[o,a,l]of i){const _=s.find(r[o]),c=s.find(r[a]);_!==c&&(n.push([o,a,l]),s.union(_,c))}return n.sort((o,a)=>o[2]-a[2])}init(){const{metric:t}=this._parameters;return this.Y=new w(this._N,2,0),this._Emst=this._make_minimum_spanning_tree(t),this._is_initialized=!0,this}__hull_cross([t,e],[r,s],[n,i]){return(r-t)*(i-e)-(s-e)*(n-t)<=0}__hull(t){const e=t.sort(([i,o],[a,l])=>o-l||i-a),r=e.length;if(r<=2)return e;const s=[];for(let i=0;i<r;++i){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[i]);)s.pop();s.push(e[i])}const n=[];for(let i=r-1;i>=0;--i){for(;n.length>=2&&this.__hull_cross(n[n.length-2],n[n.length-1],e[i]);)n.pop();n.push(e[i])}return n.pop(),s.pop(),s.concat(n)}__findAngle([t,e],[r,s]){const n=x([t,e],[r,s]);if(n===0)return{sin:0,cos:1};const i=[(r-t)/n,(s-e)/n],o=i[0];let a=Math.sqrt(1-o*o);return a=i[1]>=0?-a:a,{sin:a,cos:o}}__align_hull(t,e,r){let s,n,i,o=-1;for(let l=0;l<t.length;++l){const _=x(t[l],e);(o===-1||s>_)&&(s=_,o=l)}r?(n=t[o],i=t[(o+1)%t.length]):(o==0&&(o=t.length-1),n=t[o],i=t[(o-1)%t.length]);const a={tx:-t[o][0],ty:-t[o][1]};if(t.length>=2){const{sin:l,cos:_}=this.__findAngle(n,i);a.sin=l,a.cos=_}else a.sin=0,a.cos=1;return a}__transform([t,e],{tx:r,ty:s,sin:n,cos:i}){let o=t+r,a=e+s;return[o*i-a*n,o*n+a*i]}__transform_component(t,e,r){const s=t.length;for(let n=0;n<s;++n){const i=t[n],[o,a]=this.__transform(i,e);i[0]=o,i[1]=a+r}}__align_components(t,e,r){const s=[...t.__disjoint_set.children],n=[...e.__disjoint_set.children],i=this.__hull(s),o=this.__hull(n),a=this.__align_hull(i,t,!1),l=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(n,l,r)}transform(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new G(e.map((s,n)=>(s.i=n,s)));for(const[s,n,i]of t){const o=r.find(e[s]),a=r.find(e[n]);o!==a&&(this.__align_components(o,a,i),r.union(o,a))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new G(e.map((s,n)=>(s.i=n,s)));for(const[s,n,i]of t){const o=r.find(e[s]),a=r.find(e[n]);o!==a&&(this.__align_components(o,a,i),r.union(o,a),yield this.projection)}return this.projection}}class se extends S{constructor(t,e){return super(t,{magic:.1,d:2,metric:x,seed:1212,init_DR:"random",init_parameters:{}},e),this}init(){const t=this.X.shape[0],{d:e,metric:r,init_DR:s,init_parameters:n}=this._parameters;if(s==="random"){const i=this._randomizer;this.Y=new w(t,e,()=>i.random)}else{if(!["PCA","MDS"].includes(s))throw new Error('init_DR needs to be either "random" or a DR method!');this.Y=w.from(s=="PCA"?et.transform(this.X,n):rt.transform(this.X,n))}return this.distance_matrix=r=="precomputed"?w.from(this.X):R(this.X,r),this}transform(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,r=this.X.shape[0],{d:s,metric:n}=this._parameters;let i=this.Y,o=new w(r,s,0),a=new Float64Array(s);for(let l=0;l<r;++l){let _=new Float64Array(s),c=new Float64Array(s);const u=i.row(l);for(let d=0;d<r;++d){if(l===d)continue;const f=i.row(d),p=new Float64Array(s);for(let v=0;v<s;++v)p[v]=u[v]-f[v];const g=n(u,f),y=e.entry(l,d),m=y-g,b=Math.max(y*g,.01);for(let v=0;v<s;++v)_[v]+=p[v]*m/b,c[v]+=(m-Math.pow(p[v],2)*(1+m/g)/g)/b}for(let d=0;d<s;++d){const f=i.entry(l,d)+(t*_[d]/Math.abs(c[d])||0);o.set_entry(l,d,f),a[d]+=f}}for(let l=0;l<s;++l)a[l]/=r;for(let l=0;l<r;++l)for(let _=0;_<s;++_)i.set_entry(l,_,o.entry(l,_)-a[_]);return i}}class ne extends S{constructor(t,e){return super(t,{d:2,metric:x,seed:1212,decay_start:.1,decay_cte:.34,init_DR:{type:"random"}},e),this}init(){const t=this._N,e=this.parameter("d");this._add=this.__add(e),this._sub_div=this.__sub_div(e),this._minus=this.__minus(e),this._mult=this.__mult(e),this._LR_init=Math.max(2,.005*t),this._LR=this._LR_init,this._offset=-Math.exp(-1/this.parameter("decay_cte")),this._momentums=new w(t,e,0),this._grads=new w(t,e,0),this._indices=N(0,t-1);const r=this._randomizer;this.Y=new w(t,e,()=>r.random-.5);const s=this.parameter("metric");s==="precomputed"?(this._HD_metric=function(n,i,o){return o.entry(n,i)},this._HD_metric_exaggeration=function(n,i,o){return Math.pow(o.entry(n,i),2)}):(this._HD_metric=function(n,i,o){return s(o.row(n),o.row(i))},this._HD_metric_exaggeration=s==x?function(n,i,o){return F(o.row(n),o.row(i))}:function(n,i,o){return Math.pow(s(o.row(n),o.row(i)),2)})}transform(t=500){this.check_init(),this._decay_start=Math.round(this.parameter("decay_start")*t);for(let e=0;e<t;++e)this._step(e,t);return this.projection}*generator(t=500){this.check_init(),this._decay_start=Math.round(this.parameter("decay_start")*t);for(let e=0;e<t;++e)this._step(e,t),yield this.projection;return this.projection}_step(t,e){const r=this._decay_start;if(t>r){const s=this.parameter("decay_cte"),n=this._offset,i=(t-r)/(e-r);this._LR=this._LR_init*(Math.exp(-i*i/s)+n),this._distance_exaggeration=!1}else this._distance_exaggeration=!0;this._nestrov_iteration(this._distance_exaggeration)}__quartets(){const t=this._N,e=t-t%4,r=this._randomizer.choice(this._indices,e),s=[];for(let n=0;n<e;n+=4)s.push(Uint32Array.of(r[n],r[n+1],r[n+2],r[n+3]));return s}_nestrov_iteration(t){const e=this._momentums.mult(.99,{inline:!0}),r=this._LR,s=this._fill_MDS_grads(this.Y.add(e),this._grads,t),[n,i]=e.shape;for(let o=0;o<n;++o){const a=s.row(o),l=B(a);if(l==0)continue;const _=r/l,c=e.row(o);for(let u=0;u<i;++u)c[u]-=_*a[u]}this.Y.add(e,{inline:!0})}_fill_MDS_grads(t,e,r=!1,s=!0){s&&e.values.fill(0);const n=this._add,i=this.X;let o;o=r==1?this._HD_metric_exaggeration:this._HD_metric;const a=new Float64Array(6),l=this.__quartets();for(const[_,c,u,d]of l){a[0]=o(_,c,i),a[1]=o(_,u,i),a[2]=o(_,d,i),a[3]=o(c,u,i),a[4]=o(c,d,i),a[5]=o(u,d,i);const f=C(a);if(f>0)for(let b=0;b<6;++b)a[b]/=f,a[b]+=1e-11;const[p,g,y,m]=this._compute_quartet_grads(t,[_,c,u,d],a);n(e.row(_),p),n(e.row(c),g),n(e.row(u),y),n(e.row(d),m)}return e}_compute_quartet_grads(t,e,[r,s,n,i,o,a]){const[l,_,c,u]=e.map(Jn=>t.row(Jn)),d=x(l,_)+1e-12,f=x(l,c)+1e-12,p=x(l,u)+1e-12,g=x(_,c)+1e-12,y=x(_,u)+1e-12,m=x(c,u)+1e-12,b=C([d,f,p,g,y,m]),[v,A,M,$]=this._ABCD_grads(l,_,c,u,d,f,p,g,y,m,r,b),[j,z,D,O]=this._ABCD_grads(l,c,_,u,f,d,p,g,m,y,s,b),[K,lt,k,J]=this._ABCD_grads(l,u,c,_,p,f,d,m,y,g,n,b),[Xn,Rn,Bn,qn]=this._ABCD_grads(_,c,l,u,g,d,y,f,m,p,i,b),[Kn,Yn,Gn,Hn]=this._ABCD_grads(_,u,l,c,y,d,g,p,m,f,o,b),[Un,Vn,Qn,Wn]=this._ABCD_grads(c,u,l,_,m,f,g,p,y,d,a,b),Z=this._add;return[Z(v,j,K,Bn,Gn,Qn),Z(A,D,J,Xn,Kn,Wn),Z(M,z,k,Rn,Hn,Un),Z($,O,lt,qn,Yn,Vn)]}_ABCD_grads(t,e,r,s,n,i,o,a,l,_,c,u){const d=n/u,f=(c-d)/u*2,p=this._minus,g=this._add,y=this._mult,m=this._sub_div;return[y(p(y(g(m(t,e,n),m(t,r,i),m(t,s,o)),d),m(t,e,n)),f),y(p(y(g(m(e,t,n),m(e,r,a),m(e,s,l)),d),m(e,t,n)),f),y(g(m(r,t,i),m(r,e,a),m(r,s,_)),d*f),y(g(m(s,t,o),m(s,e,l),m(s,r,_)),d*f)]}__minus(t){return(e,r)=>{for(let s=0;s<t;++s)e[s]-=r[s];return e}}__add(t){return(...e)=>{const r=e.length,s=e[0];for(let n=1;n<r;++n){const i=e[n];for(let o=0;o<t;++o)s[o]+=i[o]}return s}}__mult(t){return(e,r)=>{for(let s=0;s<t;++s)e[s]*=r;return e}}__sub_div(t){return(e,r,s)=>Float64Array.from({length:t},(n,i)=>(e[i]-r[i])/s)}}var ie="0.6.3",oe=Object.freeze({__proto__:null,BallTree:H,DisjointSet:G,FASTMAP:Yt,Heap:T,Hierarchical_Clustering:Jt,ISOMAP:Kt,KMeans:Zt,KMedoids:pt,KNN:ut,LDA:Gt,LLE:Ht,LSP:ee,LTSA:Ut,MDS:rt,Matrix:w,OPTICS:te,PCA:et,Randomizer:P,SAMMON:se,SQDMDS:ne,TSNE:Vt,TopoMap:re,TriMap:Wt,UMAP:Qt,canberra:Pt,chebyshev:Ot,cosine:Et,distance_matrix:R,euclidean:x,euclidean_squared:F,hamming:Ft,inner_product:qt,jaccard:kt,k_nearest_neighbors:tt,kahan_sum:Rt,linspace:N,manhattan:Tt,max:ct,min:Y,neumair_sum:C,norm:B,normalize:Xt,powell:dt,qr:_t,qr_householder:Bt,simultaneous_poweriteration:E,sokal_michener:Lt,version:ie,yule:It}),U=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function ae(h){return h&&h.__esModule&&Object.prototype.hasOwnProperty.call(h,"default")?h.default:h}var he=Array.isArray,st=he,le=typeof U=="object"&&U&&U.Object===Object&&U,_e=le,ce=_e,ue=typeof self=="object"&&self&&self.Object===Object&&self,de=ce||ue||Function("return this")(),nt=de,fe=nt,pe=fe.Symbol,it=pe,mt=it,gt=Object.prototype,me=gt.hasOwnProperty,ge=gt.toString,q=mt?mt.toStringTag:void 0;function ye(h){var t=me.call(h,q),e=h[q];try{h[q]=void 0;var r=!0}catch{}var s=ge.call(h);return r&&(t?h[q]=e:delete h[q]),s}var we=ye,ve=Object.prototype,be=ve.toString;function Ae(h){return be.call(h)}var Me=Ae,yt=it,xe=we,$e=Me,je="[object Null]",ze="[object Undefined]",wt=yt?yt.toStringTag:void 0;function De(h){return h==null?h===void 0?ze:je:wt&&wt in Object(h)?xe(h):$e(h)}var vt=De;function Se(h){return h!=null&&typeof h=="object"}var Ne=Se,Ce=vt,Ee=Ne,Te="[object Symbol]";function Oe(h){return typeof h=="symbol"||Ee(h)&&Ce(h)==Te}var ot=Oe,Pe=st,ke=ot,Fe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Le=/^\w*$/;function Ie(h,t){if(Pe(h))return!1;var e=typeof h;return e=="number"||e=="symbol"||e=="boolean"||h==null||ke(h)?!0:Le.test(h)||!Fe.test(h)||t!=null&&h in Object(t)}var Xe=Ie;function Re(h){var t=typeof h;return h!=null&&(t=="object"||t=="function")}var bt=Re,Be=vt,qe=bt,Ke="[object AsyncFunction]",Ye="[object Function]",Ge="[object GeneratorFunction]",He="[object Proxy]";function Ue(h){if(!qe(h))return!1;var t=Be(h);return t==Ye||t==Ge||t==Ke||t==He}var Ve=Ue,Qe=nt,We=Qe["__core-js_shared__"],Je=We,at=Je,At=function(){var h=/[^.]+$/.exec(at&&at.keys&&at.keys.IE_PROTO||"");return h?"Symbol(src)_1."+h:""}();function Ze(h){return!!At&&At in h}var tr=Ze,er=Function.prototype,rr=er.toString;function sr(h){if(h!=null){try{return rr.call(h)}catch{}try{return h+""}catch{}}return""}var nr=sr,ir=Ve,or=tr,ar=bt,hr=nr,lr=/[\\^$.*+?()[\]{}|]/g,_r=/^\[object .+?Constructor\]$/,cr=Function.prototype,ur=Object.prototype,dr=cr.toString,fr=ur.hasOwnProperty,pr=RegExp("^"+dr.call(fr).replace(lr,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function mr(h){if(!ar(h)||or(h))return!1;var t=ir(h)?pr:_r;return t.test(hr(h))}var gr=mr;function yr(h,t){return h==null?void 0:h[t]}var wr=yr,vr=gr,br=wr;function Ar(h,t){var e=br(h,t);return vr(e)?e:void 0}var Mt=Ar,Mr=Mt,xr=Mr(Object,"create"),V=xr,xt=V;function $r(){this.__data__=xt?xt(null):{},this.size=0}var jr=$r;function zr(h){var t=this.has(h)&&delete this.__data__[h];return this.size-=t?1:0,t}var Dr=zr,Sr=V,Nr="__lodash_hash_undefined__",Cr=Object.prototype,Er=Cr.hasOwnProperty;function Tr(h){var t=this.__data__;if(Sr){var e=t[h];return e===Nr?void 0:e}return Er.call(t,h)?t[h]:void 0}var Or=Tr,Pr=V,kr=Object.prototype,Fr=kr.hasOwnProperty;function Lr(h){var t=this.__data__;return Pr?t[h]!==void 0:Fr.call(t,h)}var Ir=Lr,Xr=V,Rr="__lodash_hash_undefined__";function Br(h,t){var e=this.__data__;return this.size+=this.has(h)?0:1,e[h]=Xr&&t===void 0?Rr:t,this}var qr=Br,Kr=jr,Yr=Dr,Gr=Or,Hr=Ir,Ur=qr;function L(h){var t=-1,e=h==null?0:h.length;for(this.clear();++t<e;){var r=h[t];this.set(r[0],r[1])}}L.prototype.clear=Kr,L.prototype.delete=Yr,L.prototype.get=Gr,L.prototype.has=Hr,L.prototype.set=Ur;var Vr=L;function Qr(){this.__data__=[],this.size=0}var Wr=Qr;function Jr(h,t){return h===t||h!==h&&t!==t}var Zr=Jr,ts=Zr;function es(h,t){for(var e=h.length;e--;)if(ts(h[e][0],t))return e;return-1}var Q=es,rs=Q,ss=Array.prototype,ns=ss.splice;function is(h){var t=this.__data__,e=rs(t,h);if(e<0)return!1;var r=t.length-1;return e==r?t.pop():ns.call(t,e,1),--this.size,!0}var os=is,as=Q;function hs(h){var t=this.__data__,e=as(t,h);return e<0?void 0:t[e][1]}var ls=hs,_s=Q;function cs(h){return _s(this.__data__,h)>-1}var us=cs,ds=Q;function fs(h,t){var e=this.__data__,r=ds(e,h);return r<0?(++this.size,e.push([h,t])):e[r][1]=t,this}var ps=fs,ms=Wr,gs=os,ys=ls,ws=us,vs=ps;function I(h){var t=-1,e=h==null?0:h.length;for(this.clear();++t<e;){var r=h[t];this.set(r[0],r[1])}}I.prototype.clear=ms,I.prototype.delete=gs,I.prototype.get=ys,I.prototype.has=ws,I.prototype.set=vs;var bs=I,As=Mt,Ms=nt,xs=As(Ms,"Map"),$s=xs,$t=Vr,js=bs,zs=$s;function Ds(){this.size=0,this.__data__={hash:new $t,map:new(zs||js),string:new $t}}var Ss=Ds;function Ns(h){var t=typeof h;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?h!=="__proto__":h===null}var Cs=Ns,Es=Cs;function Ts(h,t){var e=h.__data__;return Es(t)?e[typeof t=="string"?"string":"hash"]:e.map}var W=Ts,Os=W;function Ps(h){var t=Os(this,h).delete(h);return this.size-=t?1:0,t}var ks=Ps,Fs=W;function Ls(h){return Fs(this,h).get(h)}var Is=Ls,Xs=W;function Rs(h){return Xs(this,h).has(h)}var Bs=Rs,qs=W;function Ks(h,t){var e=qs(this,h),r=e.size;return e.set(h,t),this.size+=e.size==r?0:1,this}var Ys=Ks,Gs=Ss,Hs=ks,Us=Is,Vs=Bs,Qs=Ys;function X(h){var t=-1,e=h==null?0:h.length;for(this.clear();++t<e;){var r=h[t];this.set(r[0],r[1])}}X.prototype.clear=Gs,X.prototype.delete=Hs,X.prototype.get=Us,X.prototype.has=Vs,X.prototype.set=Qs;var Ws=X,jt=Ws,Js="Expected a function";function ht(h,t){if(typeof h!="function"||t!=null&&typeof t!="function")throw new TypeError(Js);var e=function(){var r=arguments,s=t?t.apply(this,r):r[0],n=e.cache;if(n.has(s))return n.get(s);var i=h.apply(this,r);return e.cache=n.set(s,i)||n,i};return e.cache=new(ht.Cache||jt),e}ht.Cache=jt;var Zs=ht,tn=Zs,en=500;function rn(h){var t=tn(h,function(r){return e.size===en&&e.clear(),r}),e=t.cache;return t}var sn=rn,nn=sn,on=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,an=/\\(\\)?/g,hn=nn(function(h){var t=[];return h.charCodeAt(0)===46&&t.push(""),h.replace(on,function(e,r,s,n){t.push(s?n.replace(an,"$1"):r||e)}),t}),ln=hn;function _n(h,t){for(var e=-1,r=h==null?0:h.length,s=Array(r);++e<r;)s[e]=t(h[e],e,h);return s}var cn=_n,zt=it,un=cn,dn=st,fn=ot,pn=1/0,Dt=zt?zt.prototype:void 0,St=Dt?Dt.toString:void 0;function Nt(h){if(typeof h=="string")return h;if(dn(h))return un(h,Nt)+"";if(fn(h))return St?St.call(h):"";var t=h+"";return t=="0"&&1/h==-pn?"-0":t}var mn=Nt,gn=mn;function yn(h){return h==null?"":gn(h)}var wn=yn,vn=st,bn=Xe,An=ln,Mn=wn;function xn(h,t){return vn(h)?h:bn(h,t)?[h]:An(Mn(h))}var $n=xn,jn=ot,zn=1/0;function Dn(h){if(typeof h=="string"||jn(h))return h;var t=h+"";return t=="0"&&1/h==-zn?"-0":t}var Sn=Dn,Nn=$n,Cn=Sn;function En(h,t){t=Nn(t,h);for(var e=0,r=t.length;h!=null&&e<r;)h=h[Cn(t[e++])];return e&&e==r?h:void 0}var Tn=En,On=Tn;function Pn(h,t,e){var r=h==null?void 0:On(h,t);return r===void 0?e:r}var kn=Pn,Fn=ae(kn);const Ln=200;function In(h){return Array.isArray(h)?Array.isArray(h[0])?"multivector":"vector":typeof h=="object"?h.indices?"sparse":"named":"unknown"}self.onmessage=function(h){var o,a,l,_,c;let t=new Date().getTime();const e=((o=h==null?void 0:h.data)==null?void 0:o.params)||{},r=e.algorithm||"TSNE",s=[],n=(l=(a=h.data)==null?void 0:a.result)==null?void 0:l.points,i=e.vector_name;if(!n||n.length===0){self.postMessage({data:[],error:"No data found"});return}if(n.length===1){self.postMessage({data:[],error:"cannot perform tsne on single point"});return}for(let u=0;u<n.length;u++)i?s.push(Fn((c=n[u])==null?void 0:c.vector,i)):s.push((_=n[u])==null?void 0:_.vector);for(let u=0;u<s.length;u++){const d=s[u],f=In(d);if(f!=="vector"){if(f==="named"){self.postMessage({data:[],error:"Please select a valid vector name, default vector is not defined"});return}self.postMessage({data:[],error:"Vector visualization is not supported for vector type: "+f});return}}if(s.length){const d=new oe[r](s,{}).generator();let f=[];for(f of d)Date.now()-t>Ln&&(t=Date.now(),self.postMessage({result:Ct(f),error:null}));self.postMessage({result:Ct(f),error:null})}};function Ct(h){return h.map(t=>({x:t[0],y:t[1]}))}})();
